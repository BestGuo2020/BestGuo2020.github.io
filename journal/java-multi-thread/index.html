<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="BestGuo2020"><meta name="copyright" content="BestGuo2020"><meta name="generator" content="Hexo 7.0.0"><meta name="theme" content="hexo-theme-yun"><title>Java 的多线程 | BestGuo 的小窝</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.4.1/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" type="image/png" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"www.bestguo.top","root":"/","title":["Best","Guo","的","小","窝"],"version":"1.10.11","mode":"time","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","say":{"api":"https://el-bot-api.vercel.app/api/words/young"},"local_search":{"path":"/search.xml"},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false,"src":"/js/search/local-search.js"},"fireworks":{"colors":null},"waline":{"config":{"enable":true,"serverURL":"https://comment.bestguo.top","comment":true,"requiredFields":["nick","mail"],"placeholder":"有什么想要对 BestGuo 说的呢，输入正确有效的邮箱有机会收到回复哟😊😊","avatarCDN":"https://seccdn.libravatar.org/avatar/","emoji":["https://unpkg.com/@waline/emojis@1.0.1/weibo/","https://unpkg.com/@waline/emojis@1.0.1/bilibili/","https://unpkg.com/@waline/emojis@1.0.1/qq/","https://unpkg.com/@waline/emojis@1.0.1/tieba/"],"avatar":"monsterid","el":"#waline","lang":"zh-CN"},"cdn":"https://fastly.jsdelivr.net/npm/@waline/client@v2/dist/waline.js","dark":"html.dark"},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><link rel="preconnect" href="https://www.google-analytics.com" crossorigin><script async src="https://www.googletagmanager.com/gtag/js?id=G-907LWSSHLS"></script><script>if (CONFIG.hostname === location.hostname) {
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-907LWSSHLS');
}</script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else {
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script><meta name="description" content="进程和线程进程，绝大部分使用过电脑的人都知道这东西。进程是一个正在运行的应用程序，Windows 上打开任务管理器就可以看到许许多多的进程，有什么系统进程和用户进程。  线程，线程似乎绝大部分使用的过电脑的人都不是很熟悉，也许只在“性能”模块中的“CPU”中看到线程数。线程是进程的一个执行单元，这怎么解释呢？比如著名的 x 狗浏览器（非恰饭），有一个线程是用户加载浏览器的界面的，有一个线程是用于加">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 的多线程">
<meta property="og:url" content="https://www.bestguo.top/journal/java-multi-thread/index.html">
<meta property="og:site_name" content="BestGuo 的小窝">
<meta property="og:description" content="进程和线程进程，绝大部分使用过电脑的人都知道这东西。进程是一个正在运行的应用程序，Windows 上打开任务管理器就可以看到许许多多的进程，有什么系统进程和用户进程。  线程，线程似乎绝大部分使用的过电脑的人都不是很熟悉，也许只在“性能”模块中的“CPU”中看到线程数。线程是进程的一个执行单元，这怎么解释呢？比如著名的 x 狗浏览器（非恰饭），有一个线程是用户加载浏览器的界面的，有一个线程是用于加">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.bestguo.top/journal/java-multi-thread/image-20210806100924445.png">
<meta property="og:image" content="https://www.bestguo.top/journal/java-multi-thread/QQ%E6%88%AA%E5%9B%BE20210625220159.png">
<meta property="og:image" content="https://www.bestguo.top/journal/java-multi-thread/image-20210806154504981.png">
<meta property="og:image" content="https://www.bestguo.top/journal/java-multi-thread/3twyk3y17w.png">
<meta property="article:published_time" content="2021-08-05T07:50:03.000Z">
<meta property="article:modified_time" content="2023-04-08T15:41:17.251Z">
<meta property="article:author" content="BestGuo2020">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.bestguo.top/journal/java-multi-thread/image-20210806100924445.png"><script>(function() {
  if (CONFIG.mode !== 'auto') return
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="BestGuo2020"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="BestGuo2020"><span class="site-author-status" title="打工中">👨‍💻</span></a><div class="site-author-name"><a href="/about/">BestGuo2020</a></div><a class="site-name" href="/about/site.html">BestGuo 的小窝</a><sub class="site-subtitle">face-lift</sub><div class="site-description">一个人的世界是如此的安静</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">89</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">23</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">53</span></a></div><a class="site-state-item hty-icon-button" href="/albums/" title="相册集"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:gallery-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://wpa.qq.com/msgrd?v=3&amp;uin=1540113012&amp;site=qq&amp;menu=yes" title="QQ：xiaohehe2021" target="_blank" style="color:#12B7F5"><span class="icon iconify" data-icon="ri:qq-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/bestguo2020" title="GitHub：BestGuo2020" target="_blank" style="color:#8251e6"><span class="icon iconify" data-icon="ri:github-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/184681623" title="哔哩哔哩: 我叫人员外婆" target="_blank" style="color:#FF8EB3"><span class="icon iconify" data-icon="ri:bilibili-line"></span></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:bestguo2020@foxmail.com" title="E-Mail" target="_blank" style="color:#8E71C1"><span class="icon iconify" data-icon="ri:mail-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">进程和线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.</span> <span class="toc-text">线程和进程的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">java 中的线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">创建一个线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-Thread-%E7%B1%BB"><span class="toc-number">3.1.1.</span> <span class="toc-text">继承 Thread 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-Runnable-%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.1.2.</span> <span class="toc-text">实现 Runnable 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-number">3.1.3.</span> <span class="toc-text">运行结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E8%AE%AE%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.4.</span> <span class="toc-text">建议创建线程的方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A8%E7%96%91"><span class="toc-number">3.2.</span> <span class="toc-text">质疑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E7%AD%94"><span class="toc-number">3.3.</span> <span class="toc-text">解答</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">4.</span> <span class="toc-text">线程的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C"><span class="toc-number">5.</span> <span class="toc-text">java 多线程的一些简单操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E3%80%81%E4%BF%AE%E6%94%B9%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8D%E5%AD%97"><span class="toc-number">5.1.</span> <span class="toc-text">获取、修改线程的名字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.2.</span> <span class="toc-text">获取当前线程的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%91%E7%9C%A0%E4%B8%8E%E5%94%A4%E9%86%92"><span class="toc-number">5.3.</span> <span class="toc-text">线程休眠与唤醒</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.4.</span> <span class="toc-text">终止一个线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E4%BC%91%E7%9C%A0%E7%9A%84%E7%96%91%E9%97%AE"><span class="toc-number">5.5.</span> <span class="toc-text">关于线程休眠的疑问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E8%B0%83%E5%BA%A6"><span class="toc-number">6.</span> <span class="toc-text">java 多线程的一些调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">6.1.</span> <span class="toc-text">线程优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%AE%A9%E4%BD%8D"><span class="toc-number">6.2.</span> <span class="toc-text">线程让位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%88%E5%B9%B6"><span class="toc-number">6.3.</span> <span class="toc-text">线程合并</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">7.</span> <span class="toc-text">线程安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.1.</span> <span class="toc-text">代码示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%89%E4%B8%AA%E6%9D%A1%E4%BB%B6"><span class="toc-number">7.2.</span> <span class="toc-text">存在安全问题的三个条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="toc-number">7.3.</span> <span class="toc-text">解决办法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E7%A7%8D%E5%8F%98%E9%87%8F%E4%B8%8D%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">7.4.</span> <span class="toc-text">哪种变量不会出现线程安全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%85%B3%E9%94%AE%E5%AD%97%E5%86%99%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%8A"><span class="toc-number">7.5.</span> <span class="toc-text">同步关键字写在方法上</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84"><span class="toc-number">7.6.</span> <span class="toc-text">java 有哪些类是线程安全的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B9%8B%E5%90%8E%E6%95%88%E7%8E%87%E4%BC%9A%E9%99%8D%E4%BD%8E"><span class="toc-number">7.7.</span> <span class="toc-text">为什么线程同步之后效率会降低</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8A%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">7.8.</span> <span class="toc-text">在静态方法上使用同步关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="toc-number">8.</span> <span class="toc-text">线程死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">9.</span> <span class="toc-text">守护线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%A7%8D%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">10.</span> <span class="toc-text">第三种创建线程的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wait-%E5%92%8C-notify"><span class="toc-number">11.</span> <span class="toc-text">wait 和 notify</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#wait"><span class="toc-number">11.1.</span> <span class="toc-text">wait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#notify"><span class="toc-number">11.2.</span> <span class="toc-text">notify</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">11.3.</span> <span class="toc-text">使用情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">12.</span> <span class="toc-text">生产者和消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E7%BA%BF%E7%A8%8B%E7%B1%BB"><span class="toc-number">12.1.</span> <span class="toc-text">生产者线程类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E7%BA%BF%E7%A8%8B%E7%B1%BB"><span class="toc-number">12.2.</span> <span class="toc-text">消费者线程类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%B5%8B%E8%AF%95"><span class="toc-number">12.3.</span> <span class="toc-text">主线程测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">13.</span> <span class="toc-text">volatile 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">14.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">15.</span> <span class="toc-text">原子性</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="https://www.bestguo.top/journal/java-multi-thread/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="BestGuo2020"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="BestGuo 的小窝"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java 的多线程</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="创建时间：2021-08-05 15:50:03" itemprop="dateCreated datePublished" datetime="2021-08-05T15:50:03+08:00">2021-08-05</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <time title="修改时间：2023-04-08 23:41:17" itemprop="dateModified" datetime="2023-04-08T23:41:17+08:00">2023-04-08</time></div><span class="post-busuanzi"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读次数"><span class="icon iconify" data-icon="ri:eye-line"></span> <span id="busuanzi_value_page_pv"></span></span></span><span class="post-meta-divider">-</span><a href="#comment"><span class="post-meta-item-icon" title="评论数"><span class="icon iconify" data-icon="ri:chat-3-line"></span> <span class="waline-comment-count" id="/journal/java-multi-thread/"></span></span></a><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><span class="icon iconify" data-icon="ri:folder-line"></span></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">后端开发</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/Java/" style="--text-color:#ff9900"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">Java</span></a><a class="tag-item" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">多线程</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>进程，绝大部分使用过电脑的人都知道这东西。进程是一个正在运行的应用程序，Windows 上打开任务管理器就可以看到许许多多的进程，有什么系统进程和用户进程。</p>
<p><img src="/journal/java-multi-thread/image-20210806100924445.png" alt="image-20210806100924445" loading="lazy"></p>
<p>线程，线程似乎绝大部分使用的过电脑的人都不是很熟悉，也许只在“性能”模块中的“CPU”中看到线程数。线程是进程的一个执行单元，这怎么解释呢？比如著名的 x 狗浏览器（非恰饭），有一个线程是用户加载浏览器的界面的，有一个线程是用于加载页面，有一个线程是用于下载图片的。每一个线程都在做着自己该做的工作，各司其职。</p>
<p><img src="/journal/java-multi-thread/QQ%E6%88%AA%E5%9B%BE20210625220159.png" loading="lazy"></p>
<p>进程，好比一家公司。而线程，就好比公司里的员工，为公司创造价值。</p>
<span id="more"></span>

<h2 id="线程和进程的关系"><a href="#线程和进程的关系" class="headerlink" title="线程和进程的关系"></a>线程和进程的关系</h2><p>前面提到过，线程是进程的一个执行单元。一个进程中必须要有一个进程，可以有多个进程。</p>
<p>每一个进程都有一个独立的内存空间，每一个线程都可以使用进程所开辟的内存空间中的内容。</p>
<p>这就可以比喻成，你可以使用你所在的公司里的 wifi 来上网，使用公司里的空调来享受着带来的凉爽。但是不能使用其它进程中的内存空间。</p>
<p>比如你是拼夕夕的员工，你想直接去京东蹭 wifi 吗，这能行吗？这显然是不可以的。线程也是如此。</p>
<h2 id="java-中的线程"><a href="#java-中的线程" class="headerlink" title="java 中的线程"></a>java 中的线程</h2><p>在 java 中，我们平时写的控制台程序，运行时认为只有一个线程，也就是 main 方法所执行的线程。但是并不是，还有一个垃圾回收器的线程，总共有两个线程。垃圾回收器的目的就是将无用的资源释放掉，为 java 虚拟机腾出更多的内存空间，由于这里主要是讨论多线程，关于垃圾回收器，这里不过多赘述。</p>
<p><strong>那，我们可以自己创建线程吗？</strong></p>
<p>这不是 FIFA 嘛，写这篇日志的目的就是让我自己能够更加的了解 java 的线程，以及线程中的一些问题。</p>
<p><strong>提个简单的问题吧</strong></p>
<p>我最近在学习的时候，看到一个这样的代码，他问，程序在执行时共开启了多少个线程？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Question1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] a)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main执行--------&quot;</span>);</span><br><span class="line">        method1();</span><br><span class="line">        System.out.println(<span class="string">&quot;main结束--------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method1执行--------&quot;</span>);</span><br><span class="line">        method2();</span><br><span class="line">        System.out.println(<span class="string">&quot;method1结束--------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method2执行--------&quot;</span>);</span><br><span class="line">        method3();</span><br><span class="line">        System.out.println(<span class="string">&quot;method2结束--------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method3执行--------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请不要立即展开，先思考 30 秒钟。</p>
<details>
    <p>怎么样，肯定有人认为这是 4 个线程吧。其实，线程只有 1 个！</p>
    <p>因为这很简单，只是方法之间的调用而已呀。</p>
</details>

<h3 id="创建一个线程"><a href="#创建一个线程" class="headerlink" title="创建一个线程"></a>创建一个线程</h3><p>线程的创建非常简单的，总共有三种方法。目前我也是刚刚学，所以目前只知道两种创建线程的方式，一个是通过继承 Thread 类来创建线程，一个是通过自己实现 Runnable 接口来创建线程。</p>
<p>然后再调用 start 方法去创建线程，这样，一个线程就这样成功的开起了。</p>
<h4 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h4><p>继承 Thread 类的相关代码如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        myThread.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程------&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用继承的方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程------&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h4><p>实现 Runnable 接口创建线程的代码如下所示。这里使用到的方式是使用匿名内部类的方式，当然，你可以创建一个类来实现 Runnable 接口的方式，实例化你创建的类，传入到 Thread 类中的构造方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnableTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;子线程------&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        myThread.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程------&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>由于运行结果实在是太长了，我将运行的结果进行折叠了。后续的运行结果也是如此</p>
<details>
    <summary>点击查看运行结果</summary>
<pre>
主线程------0
子线程------0
子线程------1
子线程------2
子线程------3
子线程------4
子线程------5
子线程------6
子线程------7
子线程------8
子线程------9
子线程------10
子线程------11
子线程------12
子线程------13
子线程------14
子线程------15
子线程------16
子线程------17
子线程------18
子线程------19
子线程------20
子线程------21
子线程------22
子线程------23
子线程------24
子线程------25
子线程------26
子线程------27
子线程------28
子线程------29
子线程------30
子线程------31
子线程------32
子线程------33
子线程------34
子线程------35
子线程------36
子线程------37
子线程------38
子线程------39
子线程------40
子线程------41
子线程------42
子线程------43
子线程------44
子线程------45
子线程------46
子线程------47
子线程------48
子线程------49
子线程------50
子线程------51
子线程------52
子线程------53
子线程------54
子线程------55
子线程------56
子线程------57
子线程------58
子线程------59
子线程------60
子线程------61
子线程------62
子线程------63
子线程------64
子线程------65
子线程------66
子线程------67
子线程------68
子线程------69
子线程------70
子线程------71
子线程------72
子线程------73
子线程------74
子线程------75
子线程------76
子线程------77
子线程------78
子线程------79
子线程------80
子线程------81
主线程------1
主线程------2
主线程------3
子线程------82
子线程------83
子线程------84
子线程------85
子线程------86
子线程------87
子线程------88
子线程------89
子线程------90
子线程------91
子线程------92
子线程------93
子线程------94
子线程------95
子线程------96
子线程------97
子线程------98
子线程------99
主线程------4
主线程------5
主线程------6
主线程------7
主线程------8
主线程------9
主线程------10
主线程------11
主线程------12
主线程------13
主线程------14
主线程------15
主线程------16
主线程------17
主线程------18
主线程------19
主线程------20
主线程------21
主线程------22
主线程------23
主线程------24
主线程------25
主线程------26
主线程------27
主线程------28
主线程------29
主线程------30
主线程------31
主线程------32
主线程------33
主线程------34
主线程------35
主线程------36
主线程------37
主线程------38
主线程------39
主线程------40
主线程------41
主线程------42
主线程------43
主线程------44
主线程------45
主线程------46
主线程------47
主线程------48
主线程------49
主线程------50
主线程------51
主线程------52
主线程------53
主线程------54
主线程------55
主线程------56
主线程------57
主线程------58
主线程------59
主线程------60
主线程------61
主线程------62
主线程------63
主线程------64
主线程------65
主线程------66
主线程------67
主线程------68
主线程------69
主线程------70
主线程------71
主线程------72
主线程------73
主线程------74
主线程------75
主线程------76
主线程------77
主线程------78
主线程------79
主线程------80
主线程------81
主线程------82
主线程------83
主线程------84
主线程------85
主线程------86
主线程------87
主线程------88
主线程------89
主线程------90
主线程------91
主线程------92
主线程------93
主线程------94
主线程------95
主线程------96
主线程------97
主线程------98
主线程------99
</pre>
</details>

<h4 id="建议创建线程的方式"><a href="#建议创建线程的方式" class="headerlink" title="建议创建线程的方式"></a>建议创建线程的方式</h4><p>强烈建议使用实现 Runnable 接口的方式，因为在 java 中，继承只能是单一的继承，不能多继承，如果使用继承 Thread 的方式，就会出现这样的问题。而在 java 中，可以这样子写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example1</span> <span class="keyword">extends</span> <span class="title class_">AbstractModule</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="质疑"><a href="#质疑" class="headerlink" title="质疑"></a>质疑</h3><ol>
<li>为什么我运行的结果和视频上运行的结果是完全不一样的呀？</li>
<li>为什么我运行的时候，总是主线程现执行而不是子线程先执行？</li>
<li>主线程一定是最先运行的吗，子线程就没有先输出的权利吗？</li>
<li>你看，我的运行结果完了之后，它就是主线程先执行完再执行子线程，这我觉得和单线程没什么区别呀？</li>
<li>调用 start 方法和调用的 run 的方法好像没什么区别吧？</li>
<li>……</li>
</ol>
<p>以上是我在多线程学习时，我目前所遇到的疑问，可能还有其它的问题。显然，出现 1~4 点这样的疑问的原因绝大多是不了解的线程的生命周期所造成的。当然，第 5 点是自身 java 基础的问题了。</p>
<p>这也是我大专时期刚学习 java 的时候学习多线程部分所碰到的问题。</p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>先从最简单的第 5 点开始说起吧。</p>
<p>调用 run 方法和调用 start 方法的都是一样的，都是入栈和弹栈，仅仅只是调用了类中的方法而已。但是仔细思考，run 方法里面的内容是什么？比如上面那两个例子，run 方法是需要自己实现的，实现的里面是一个 for 循环。而 start 方法里面是啥，我把内容放出来如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * This method is not invoked for the main method thread or &quot;system&quot;</span></span><br><span class="line"><span class="comment">      * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">      * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * A zero status value corresponds to state &quot;NEW&quot;.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">     * so that it can be added to the group&#x27;s list of threads</span></span><br><span class="line"><span class="comment">     * and the group&#x27;s unstarted count can be decremented. */</span></span><br><span class="line">    group.add(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                  it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先不看这里面复杂的内容，但是没有看到 start 方法里有在调用 run 方法。这就意味着，start 方法和 run 方法是两个不同的东西。创建出来的线程，这个 run 方法其实就相当于主线程中的 main 方法一样的。</p>
<p>也就是说 start 方法就是创建线程用的。</p>
<p>以上的四个问题，就单独用一个内容来说。</p>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>线程主要有 5 种状态，分别是 “创建”、“就绪”、“运行”、“阻塞” 和 “死亡” 这 5 种状态。可以用这张图来描述一下。</p>
<blockquote>
<p>什么是时间片？如果你学过痛苦的操作系统，你就知道。</p>
<p>时间片即 CPU 分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片，即该线程允许运行的时间。</p>
</blockquote>
<p><img src="/journal/java-multi-thread/image-20210806154504981.png" alt="image-20210806154504981" loading="lazy"></p>
<p>在 java 中，通过创建出来的 Thread 对象，要想真正的创建出线程，则必须调用其 start 方法。调用它的 start 方法，此时线程创建完成。</p>
<p>创建的线程能够直接运行吗？当然不能，要先进入就绪状态，等待 CPU 的调度才能够执行。假如这个程序中共有 2 个线程，当第一个程序的时间片到了，他就需要进入就绪状态，等待 CPU 的调度。但是第二个线程一定会运行状态么？显然这是不一定的，有可能线程 1 会继续执行，也有可能线程 2 会继续执行。这就有了上面的示例所输出的结果，即主线程执行到 0 ，子线程就突然从 0 一次性执行到 99，也就有了每次输出都是不同的结果的原因了。</p>
<p>由于 CPU 的切换的频率非常之快。这就看起来像是，宏观上是并行（同时运行），微观上是串行（一个一个运行）。</p>
<p>那阻塞状态什么时候会出现呐？比如，线程 2 中突然遇到了键盘输入的操作，需要等待用户输入完成才能执行的下一步操作，在输入完成之前，处于运行状态的线程 2 就进入了阻塞状态，此时线程 1 受到 CPU 的调度继续执行着。用户输入完成之后，线程 2 只好进入就绪的状态了，等待 CPU 的调度了。</p>
<p>那死亡状态又是怎么一回事？在 java 中，死亡状态就是线程中的 run 方法，或者主线程的 main 方法中的代码运行结束了。线程就处于死亡状态了。</p>
<p>但是，主线程运行结束了，子线程就提前挂了吗？这是绝对不可能的。</p>
<p>其实，主线程和子线程并不是“父子”关系，而是“兄弟”关系。</p>
<h2 id="java-多线程的一些简单操作"><a href="#java-多线程的一些简单操作" class="headerlink" title="java 多线程的一些简单操作"></a>java 多线程的一些简单操作</h2><p>比如，获取、修改线程的名字，获取当前线程的对象，让当前线程休眠（进入阻塞状态），唤醒正在休眠的线程，强行正在运行的线程，合理的关闭正在运行的线程。</p>
<h3 id="获取、修改线程的名字"><a href="#获取、修改线程的名字" class="headerlink" title="获取、修改线程的名字"></a>获取、修改线程的名字</h3><p>使用 setName 方法来修改线程的名字，使用 getName 方法来获取线程的名字</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 设置线程名字</span></span><br><span class="line">t1.setName(<span class="string">&quot;小赫赫&quot;</span>);</span><br><span class="line">System.out.println(t1.getName());</span><br></pre></td></tr></table></figure>

<h3 id="获取当前线程的对象"><a href="#获取当前线程的对象" class="headerlink" title="获取当前线程的对象"></a>获取当前线程的对象</h3><p>获取当前线程对象的方式也很简单，使用 currentThread 方法来调用当前的线程对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">currentThread</span> <span class="operator">=</span> Thread.currentThread();</span><br></pre></td></tr></table></figure>

<p>如果是在主线程下，得到的是主线程的对象。如果是自己创建的线程，就获取自己创建线程的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 新线程对象</span></span><br><span class="line">	    <span class="type">Thread</span> <span class="variable">mainThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">// do something......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 主线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">mainThread</span> <span class="operator">=</span> Thread.currentThread();</span><br></pre></td></tr></table></figure>

<h3 id="线程休眠与唤醒"><a href="#线程休眠与唤醒" class="headerlink" title="线程休眠与唤醒"></a>线程休眠与唤醒</h3><p>使用 sleep 方法来休眠一个线程。单位是毫秒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>唤醒一个线程，唤醒一个线程是需要调用线程对象的 interrupt 方法，通过 java 异常机制来唤醒线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do something......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 唤醒 t1 线程</span></span><br><span class="line">t1.interrupt();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="终止一个线程"><a href="#终止一个线程" class="headerlink" title="终止一个线程"></a>终止一个线程</h3><p>使用 stop 方法来终止强行终止一个线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do something......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">t1.stop();</span><br></pre></td></tr></table></figure>

<p>这样做其实是非常不安全的，因为这样很容易造成数据的丢失，那我们如何正常的关闭一个线程呢？</p>
<p>当然是可以的。</p>
<p>这个目前只能够通过代码的方式来终止，而不是使用线程类中的方法。</p>
<p>一个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">    <span class="comment">// 线程停止的状态</span></span><br><span class="line">    isEnd = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(isEnd) &#123;</span><br><span class="line">            <span class="comment">// do something......</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// stop to do another......</span></span><br><span class="line">        <span class="comment">// 如果是数据库的连接，则可以做关闭数据库连接的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 停止线程</span></span><br><span class="line">t1.isEnd = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h3 id="关于线程休眠的疑问"><a href="#关于线程休眠的疑问" class="headerlink" title="关于线程休眠的疑问"></a>关于线程休眠的疑问</h3><p>这里有一段代码，我调用 t 线程的 sleep 方法。那么是 t 线程会不会休眠，还是主线程会不会休眠？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Question2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread3</span>();</span><br><span class="line">        t.setName(<span class="string">&quot;t&quot;</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">//调用 t 线程的 sleep 方法</span></span><br><span class="line">        t.sleep(<span class="number">1000</span> * <span class="number">5</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    	e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    system.out.println(<span class="string">&quot;he11o world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread3</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread() . getName() + <span class="string">&quot;---&gt;&quot;</span> + i);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请不要立即展开，先思考 30 秒</p>
<details>
    <p>正确答案是，主线程休眠！</p>
    <p>怎么样，有和我一样被误认为是 t 线程休眠的吗，哈哈哈哈哈哈哈哈。</p>
    <p>因为 sleep 方法它是一个静态的方法，静态方法和静态成员变量都是随着类的加载而加载呀。所以 <code>t.sleep()</code> 和 <code>Thread.sleep()</code> 是一样的效果，只要写在哪个线程里面，就是在哪个线程中休眠。</p>
</details>

<h2 id="java-多线程的一些调度"><a href="#java-多线程的一些调度" class="headerlink" title="java 多线程的一些调度"></a>java 多线程的一些调度</h2><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>在 java 的多线程中，可以给线程设置优先级。设置线程的优先级需要获取当前的线程对象，才能够设置线程的优先级。首先，在 Thread 类中，共有三个常量。它们分别是最低优先级，正常优先级和最高优先级。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The minimum priority that a thread can have.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MIN_PRIORITY</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The default priority that is assigned to a thread.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NORM_PRIORITY</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The maximum priority that a thread can have.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX_PRIORITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>当然，线程的优先级也可以通过数字（1-10）的方式来设置。</p>
<p>以下是设置优先级的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">Thread.currentThread().setPriority(<span class="number">8</span>);</span><br><span class="line">Thread.currentThread().setPriority(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>设置优先级的目的在于让该线程处于运行态的时间会更久一些。</p>
<h3 id="线程让位"><a href="#线程让位" class="headerlink" title="线程让位"></a>线程让位</h3><p>就是当前的线程的运行时间片，让给其它线程。在 java 中，使用静态 yield 方法来将线程进行让位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.<span class="keyword">yield</span>();</span><br></pre></td></tr></table></figure>

<p>以下是一个例子，每运行到 10 的时候，就让位一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnableTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span> + thread.getName() + <span class="string">&quot;------&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.setPriority(<span class="number">7</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                Thread.<span class="keyword">yield</span>(); <span class="comment">// 每10次让给 t1 线程</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;------&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details>
    <summary>运行结果如下，请展开</summary>
<pre>
线程main------1
线程main------2
线程main------3
线程main------4
线程main------5
线程main------6
线程main------7
线程main------8
线程main------9
线程t1------1
线程t1------2
线程t1------3
线程t1------4
线程t1------5
线程t1------6
线程t1------7
线程t1------8
线程t1------9
线程t1------10
线程t1------11
线程t1------12
线程t1------13
线程t1------14
线程t1------15
线程t1------16
线程t1------17
线程t1------18
线程t1------19
线程t1------20
线程t1------21
线程t1------22
线程t1------23
线程t1------24
线程t1------25
线程t1------26
线程t1------27
线程t1------28
线程t1------29
线程t1------30
线程t1------31
线程t1------32
线程t1------33
线程t1------34
线程t1------35
线程t1------36
线程t1------37
线程t1------38
线程t1------39
线程t1------40
线程t1------41
线程t1------42
线程t1------43
线程t1------44
线程t1------45
线程t1------46
线程t1------47
线程t1------48
线程t1------49
线程t1------50
线程t1------51
线程t1------52
线程t1------53
线程t1------54
线程t1------55
线程t1------56
线程t1------57
线程t1------58
线程t1------59
线程t1------60
线程t1------61
线程t1------62
线程t1------63
线程t1------64
线程t1------65
线程t1------66
线程t1------67
线程t1------68
线程t1------69
线程t1------70
线程t1------71
线程t1------72
线程t1------73
线程t1------74
线程t1------75
线程t1------76
线程t1------77
线程t1------78
线程t1------79
线程t1------80
线程t1------81
线程t1------82
线程t1------83
线程t1------84
线程t1------85
线程t1------86
线程t1------87
线程t1------88
线程t1------89
线程t1------90
线程t1------91
线程t1------92
线程t1------93
线程t1------94
线程t1------95
线程t1------96
线程t1------97
线程t1------98
线程t1------99
线程t1------100
线程main------10
线程main------11
线程main------12
线程main------13
线程main------14
线程main------15
线程main------16
线程main------17
线程main------18
线程main------19
线程main------20
线程main------21
线程main------22
线程main------23
线程main------24
线程main------25
线程main------26
线程main------27
线程main------28
线程main------29
线程main------30
线程main------31
线程main------32
线程main------33
线程main------34
线程main------35
线程main------36
线程main------37
线程main------38
线程main------39
线程main------40
线程main------41
线程main------42
线程main------43
线程main------44
线程main------45
线程main------46
线程main------47
线程main------48
线程main------49
线程main------50
线程main------51
线程main------52
线程main------53
线程main------54
线程main------55
线程main------56
线程main------57
线程main------58
线程main------59
线程main------60
线程main------61
线程main------62
线程main------63
线程main------64
线程main------65
线程main------66
线程main------67
线程main------68
线程main------69
线程main------70
线程main------71
线程main------72
线程main------73
线程main------74
线程main------75
线程main------76
线程main------77
线程main------78
线程main------79
线程main------80
线程main------81
线程main------82
线程main------83
线程main------84
线程main------85
线程main------86
线程main------87
线程main------88
线程main------89
线程main------90
线程main------91
线程main------92
线程main------93
线程main------94
线程main------95
线程main------96
线程main------97
线程main------98
线程main------99
线程main------100
</pre>
</details>

<p>运行结果发现，当输出到 9 时（其实已经是 10 了，只是 10 是在让步之后才会打印） 。主线程就让出给其它线程 ，由于这里是 t1 就开始执行 。</p>
<p>由于 t1 已经死亡了，此时主线程在</p>
<h3 id="线程合并"><a href="#线程合并" class="headerlink" title="线程合并"></a>线程合并</h3><p>线程的合并，使用 join 方法对线程进行合并 。</p>
<p>示例如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnableTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程&quot;</span> + thread.getName() + <span class="string">&quot;------&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;------&quot;</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t1.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details>
    <summary>运行结果如下，请展开（执行结果太长，省略了部分）</summary>
<pre>
线程main------1
线程t1------1
线程t1------2
线程t1------3
线程t1------4
线程t1------5
线程t1------6
线程t1------7
线程t1------8
线程t1------9
线程t1------10
线程t1------11
线程t1------12
线程t1------13
线程t1------14
线程t1------15
线程t1------16
线程t1------17
线程t1------18
线程t1------19
线程t1------20
线程t1------21
线程t1------22
线程t1------23
线程t1------24
线程t1------25
线程t1------26
线程t1------27
线程t1------28
线程t1------29
线程t1------30
线程t1------31
线程t1------32
线程t1------33
线程t1------34
线程t1------35
线程t1------36
线程t1------37
线程t1------38
线程t1------39
线程t1------40
线程t1------41
线程t1------42
线程t1------43
线程t1------44
线程t1------45
线程t1------46
线程t1------47
线程t1------48
线程t1------49
线程t1------50
线程t1------51
线程t1------52
线程t1------53
线程t1------54
线程t1------55
线程t1------56
线程t1------57
线程t1------58
线程t1------59
线程t1------60
线程t1------61
线程t1------62
线程t1------63
线程t1------64
线程t1------65
线程t1------66
线程t1------67
线程t1------68
线程t1------69
线程t1------70
线程t1------71
线程t1------72
线程t1------73
线程t1------74
线程t1------75
线程t1------76
线程t1------77
线程t1------78
线程t1------79
线程t1------80
线程t1------81
线程t1------82
线程t1------83
线程t1------84
线程t1------85
线程t1------86
线程t1------87
线程t1------88
线程t1------89
线程t1------90
线程t1------91
线程t1------92
线程t1------93
线程t1------94
线程t1------95
线程t1------96
线程t1------97
线程t1------98
线程t1------99
线程t1------100
线程main------2
线程main------3
线程main------4
线程main------5
线程main------6
线程main------7
线程main------8
线程main------9
线程main------10
线程main------11
线程main------12
线程main------13
线程main------14
线程main------15
线程main------16
线程main------17
线程main------18
线程main------19
线程main------20
线程main------21
线程main------22
线程main------23
线程main------24
线程main------25
线程main------26
线程main------27
线程main------28
线程main------29
线程main------30
线程main------31
线程main------32
线程main------33
线程main------34
线程main------35
线程main------36
线程main------37
线程main------38
线程main------39
线程main------40
线程main------41
线程main------42
线程main------43
线程main------44
线程main------45
线程main------46
线程main------47
线程main------48
线程main------49
线程main------50
线程main------51
线程main------52
线程main------53
线程main------54
线程main------55
线程main------56
线程main------57
线程main------58
.......
线程main------9997
线程main------9998
线程main------9999
线程main------10000
</pre>
</details>

<p>运行的效果和让步一样？其实不是。和让步的区别大着呢，线程合并是 t1 线程合并到当前线程中，此时当前线程受阻（暂停执行），只能等到 t1 线程结束之后，主线程才会继续执行。</p>
<h2 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h2><p>线程安全，在多线程中是一个非常重要的问题。那什么时候会出现线程安全的问题呢？</p>
<p>举个例子吧。</p>
<p>假如我有一个账户，名字叫 xiaohehe ，账户里面这里面有 8000 元 ，我俩是在同一家银行不同的位置的 ATM 机。有一次，我去银行里取 4000 元 ，我是一个线程 ，然后我<del>女朋友（目前还没有啦）</del>这个时候也去取 4000 元 ，女朋友也是一个线程，然后我俩这时候钱，取钱的时候会出现以下情况。</p>
<p><strong>1、刚好取完</strong></p>
<p>我：取完 4000，显示的余额剩 4000</p>
<p>数据取完之后，余额更新成功。</p>
<p>女朋友：取完 4000，余额也更新成功，余额为 0 。</p>
<p><strong>2、同一时刻取钱</strong></p>
<p>我：取完 8000，余额剩 4000。</p>
<p>取完之后，由于网络很不好，导致余额还未更新，还是 8000，此时女朋友此时也取了 4000 元。</p>
<p>女朋友：取完 8000，余额剩 4000。</p>
<p>有没有发现，下面这种情况是不是多了 4000 元 。由于取钱还剩余 4000 元 。这样就出现了线程安全的问题。我们可以通过代码示例来验证这一想法。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>这是账户类，账户类中有一个取款的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">double</span> balance, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBalance</span><span class="params">(<span class="type">double</span> balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> balance)</span> &#123;</span><br><span class="line">        <span class="comment">// 取款</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">before</span> <span class="operator">=</span> getBalance();</span><br><span class="line">        <span class="comment">// 付钱</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">after</span> <span class="operator">=</span> before - balance;</span><br><span class="line">        <span class="comment">// 模拟网络延迟</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">        setBalance(after);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Account&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;balance=&quot;</span> + balance +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是用户取款的动作 Runnable ，通过它来创建线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserRunnable</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">4000</span>;</span><br><span class="line">        account.withdraw(a);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;，取了：&quot;</span> + a + <span class="string">&quot;，剩下：&quot;</span> + account.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadSecurityTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 账户</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">8000</span>, <span class="string">&quot;xiaohehe&quot;</span>);</span><br><span class="line">        <span class="comment">// 我自己</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">UserRunnable</span>(account));</span><br><span class="line">        t1.setName(<span class="string">&quot;me&quot;</span>);</span><br><span class="line">        <span class="comment">// 我女朋友</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">UserRunnable</span>(account));</span><br><span class="line">        t2.setName(<span class="string">&quot;女盆友&quot;</span>);</span><br><span class="line">        <span class="comment">// 全部开启</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行的结果如下，不管是如何运行，运行的结果都是如此。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用户：me，取了：4000.0，剩下：4000.0</span><br><span class="line">用户：女盆友，取了：4000.0，剩下：4000.0</span><br></pre></td></tr></table></figure>

<h3 id="存在安全问题的三个条件"><a href="#存在安全问题的三个条件" class="headerlink" title="存在安全问题的三个条件"></a>存在安全问题的三个条件</h3><ol>
<li>多线程并发</li>
<li>有共享的数据</li>
<li>且共享的数据具有修改的行为</li>
</ol>
<p><strong>上面的例子也正好符合这三个条件，首先账户是共享的，肯定是多线程并发的，然后取款就是修改数据的操作</strong></p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>将线程进行排队，说的专业一点就是线程同步了。使用 synchronized 同步代码块，代码的示例如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">    <span class="comment">// 需要执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步代码块中有一个小括号，那这个 obj 就是共享的对象了。如果要解决上面的线程问题，那么可以这样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> balance)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 取款</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">before</span> <span class="operator">=</span> getBalance();</span><br><span class="line">        <span class="comment">// 付钱</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">after</span> <span class="operator">=</span> before - balance;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">        setBalance(after);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>this，就是当前实例对象了，也就是 Account ，它是被我和“女盆友”共享的，可修改的，且处于并发的环境中。</p>
<h3 id="哪种变量不会出现线程安全问题"><a href="#哪种变量不会出现线程安全问题" class="headerlink" title="哪种变量不会出现线程安全问题"></a>哪种变量不会出现线程安全问题</h3><p>在 java 中，变量有三种，一个是局部变量、一个是实例变量、一个是静态变量。只有局部变量不会出现线程安全的问题。因为局部变量是保存在栈中的。</p>
<p>还有一个，就是常量。因为常量是不可修改的。</p>
<h3 id="同步关键字写在方法上"><a href="#同步关键字写在方法上" class="headerlink" title="同步关键字写在方法上"></a>同步关键字写在方法上</h3><p>如果要共享的对象就是当前的对象（this），并且要执行的代码是整个方法体，则可以在方法上使用同步关键字，比如上述的例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> balance)</span> &#123;</span><br><span class="line">    <span class="comment">// 取款</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">before</span> <span class="operator">=</span> getBalance();</span><br><span class="line">    <span class="comment">// 付钱</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">after</span> <span class="operator">=</span> before - balance;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新</span></span><br><span class="line">    setBalance(after);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后执行的效果也是一样的，这里就不重复展示结果了。</p>
<p>优点：</p>
<ol>
<li>节省代码</li>
</ol>
<p>缺点：</p>
<ol>
<li>不灵活，只能锁定当前对象（this）</li>
<li>在某些情况下，可能会无故扩大同步的范围，导致程序的执行效率降低。</li>
</ol>
<h3 id="java-有哪些类是线程安全的"><a href="#java-有哪些类是线程安全的" class="headerlink" title="java 有哪些类是线程安全的"></a>java 有哪些类是线程安全的</h3><p>举例：StringBuffer、Vector、Hashtable</p>
<p>线程不安全的：ArrayList、HashMap、HashSet、StringBuilder</p>
<h3 id="为什么线程同步之后效率会降低"><a href="#为什么线程同步之后效率会降低" class="headerlink" title="为什么线程同步之后效率会降低"></a>为什么线程同步之后效率会降低</h3><p>当某一个线程执行到同步代码块或者进入到同步函数的时候，它会放弃当前的运行状态，进入锁池去寻找锁，且锁池里面只有一把。就比如上面的例子，当我去取款的时候，我相当于在“锁池”中拿到了 “一把锁” 。</p>
<p>拿到“锁”之后，此时女盆友再取款，它也要放弃当前的运行状态，进入“锁池”里面去寻找锁。此时，女盆友就只能一直在“锁池”里找锁，要等到我取款完成之后，“锁”就自动回到锁池当中。然后女盆友找到锁了，就可以继续去取款了。</p>
<p>其中，等待的过程就可以理解成是一种阻塞状态，所以效率就低了。</p>
<p>也就是说，线程进入锁池找共享对象的对象锁的时候，会释放之前占有的CPU时间片，有可能找到了，有可能没找到，没找到则在锁池中等待，如果找到了会进入就绪状态继续抢夺 CPU 时间片。</p>
<p>如果进程中只有一个线程也是如此，同样也要进入同步代码块去锁池中拿锁。</p>
<h3 id="在静态方法上使用同步关键字"><a href="#在静态方法上使用同步关键字" class="headerlink" title="在静态方法上使用同步关键字"></a>在静态方法上使用同步关键字</h3><p>在静态方法上使用同步关键字，表示找类锁。类锁永远只有 1 把。就算创建了 100 个对象，那类锁也只有一把。</p>
<p>使用类锁来保证静态变量的安全。</p>
<p><strong>4 个有关同步关键字的面试题</strong></p>
<p>有如下代码 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSome begin&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep( millis: <span class="number">1080</span> * <span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;doSome over&quot;</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;doOther begin&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;doOther over&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个线程类。如果是 t1 线程，那么就执行 <code>doSome</code> 方法，否则就执行 <code>doOther</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> MyClass mc;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(MyClass mc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mc = mc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">&quot;t1&quot;</span>))&#123;</span><br><span class="line">            mc.doSome();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">&quot;t2&quot;</span>))&#123;</span><br><span class="line">            mc.doOther();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程中做的事情</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(mc);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(mc);</span><br><span class="line"></span><br><span class="line">t1.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t2.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);<span class="comment">//这个睡眠的作用是:为了保证t1线程先执行。</span></span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<p>问 1：如果在 <code>doSome</code> 方法添加了同步关键字，<code>doOther</code> 方法没有添加，那么 <code>doOther</code> 方法需要等待 <code>doSome</code> 方法结束吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 省略代码 ，因为上面有......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 省略代码 ，因为上面有......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details>
    <summary>思考 30s 之后再展开答案</summary>
    <p>不需要</p>
    <p>因为调用 t2 方法不是同步函数，不需要拿锁</p>
</details>

<p>问 2：如果在<code>doSome</code>、<code>doOther</code>方法都添加了同步关键字，那么 <code>doOther</code> 方法需要等待 <code>doSome</code> 方法结束吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 省略代码 ，因为上面有......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 省略代码 ，因为上面有......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<details>
    <summary>思考 30s 之后再展开答案</summary>
    <p>需要</p>
    <p>因为 t2 方法需要进入同步代码块，且将 synchronized 关键字写在实例方法上就是拿到当前对象的锁，当前对象的锁是<b style="color: red;">只有一把的！</b>，所以需要等待 doSome 方法执行结束</p>
</details>

<p>问 3：将主线程的代码改成如下形式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">mc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">mc2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(mc1);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(mc2);</span><br><span class="line"></span><br><span class="line">t1.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t2.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);<span class="comment">//这个睡眠的作用是:为了保证t1线程先执行。</span></span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<p><code>MyClass</code> 类中的方法和第二问是一样的，那么 <code>doOther</code> 方法需要等待 <code>doSome</code> 方法结束吗？</p>
<details>
    <summary>思考 30s 之后再展开答案</summary>
    <p>不需要</p>
    <p>虽然都进入了 synchronized 关键字，但是，mc1 和 mc2 是两个对象，不共享的，所以这两个线程所拿到的锁是<b style="color: red;">两把不一样的！</b>，所以不需要等待 doSome 方法执行结束</p>
</details>

<p>问 4：给<code>doSome</code>、<code>doOther</code>方法都添加了静态关键字，主线程中和第三问一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSome</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 省略代码 ，因为上面有......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doOther</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 省略代码 ，因为上面有......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么 <code>doOther</code> 方法需要等待 <code>doSome</code> 方法结束吗？</p>
<details>
    <summary>思考 30s 之后再展开答案</summary>
    <p>需要</p>
    <p>虽然都进入了 synchronized 关键字，且 mc1 和 mc2 是两个对象，不共享的，但这个方法是静态的，调用的是静态方法。所以锁的性质变了，变成了<b style="color: red;">类锁</b>，所以需要等待 doSome 方法执行结束</p>
</details>

<h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><p>线程死锁在以下情况会发生，主要是在同步代码块嵌套的情况有极大的可能会死锁。代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadLockTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(), o2 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThreadLock1</span>(o1, o2);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThreadLock2</span>(o1, o2);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThreadLock1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object o1, o2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThreadLock1</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.o1 = o1;</span><br><span class="line">        <span class="built_in">this</span>.o2 = o2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程：&quot;</span> + name + <span class="string">&quot;，运行中&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程：&quot;</span> + name + <span class="string">&quot;，运行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThreadLock2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object o1, o2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThreadLock2</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.o1 = o1;</span><br><span class="line">        <span class="built_in">this</span>.o2 = o2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程：&quot;</span> + name + <span class="string">&quot;，运行中&quot;</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程：&quot;</span> + name + <span class="string">&quot;，运行结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下，程序永远不会停止。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程：t2，运行中</span><br><span class="line">线程：t1，运行中</span><br></pre></td></tr></table></figure>

<p>因为程序已经处于死锁状态，处于死锁的原因是 o1 和 o2 是共享的，且线程 t1 拿到 o1 锁之后，t2 拿到 o2 锁 。谁也不愿意释放锁 ，所以就造成了死锁。</p>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>守护线程有一个特点，就是主线程已经结束，创建的线程不管是否完成就也会结束。这里写一个死循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaemonThreadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DaemonThread</span> <span class="variable">daemonThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DaemonThread</span>();</span><br><span class="line">        daemonThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        daemonThread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DaemonThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;循环了 &quot;</span> + (++count) + <span class="string">&quot; 次&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果就不展示了，无论如何都会结束的。</p>
<h2 id="第三种创建线程的方式"><a href="#第三种创建线程的方式" class="headerlink" title="第三种创建线程的方式"></a>第三种创建线程的方式</h2><p>创建第三种线程的方式使用的是 FutureTask 类，然后需要实现 Callable 接口。这种方式创建线程只有在 jdk 1.8 及其以上的版本才能够实现。</p>
<p>不仅如此，Callable 接口需要实现的 call 方法可是有返回值的。这样一来，我们就可以调用另一个线程中的返回值。</p>
<p>代码示例如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTaskTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;task 开始执行，等待10秒&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;task 结束执行，计算1~100的和&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    sum += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 创建一个线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 获取线程中运行的结果，当线程中的任务未结束时，它就一直等待。</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> task.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;得到的结果：&quot;</span> + integer);</span><br><span class="line">        System.out.println(<span class="string">&quot;程序运行到底了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行的结果和在线程中使用 <code>join</code>方法类似。</p>
<h2 id="wait-和-notify"><a href="#wait-和-notify" class="headerlink" title="wait 和 notify"></a>wait 和 notify</h2><p>wait 和 notify 方法不是通过线程对象的方法，是 java 中任何一个 java 对象都有的方法，因为 Object 类中就有 wait 和 notify 方法。那么，这两个方法的含义又是什么呢？</p>
<h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><p>表示 o 对象活动的线程进入等待状态，无限期等待。直到被唤醒为止。也就是说这个进程中有个对象，调用其 wait 方法。他就一直等待着。比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">u.wait();</span><br></pre></td></tr></table></figure>

<h3 id="notify"><a href="#notify" class="headerlink" title="notify"></a>notify</h3><p>唤醒正在 o 对象上等待的线程。还有一个 <code>notifyAll</code> 方法，表示的是唤醒 o 对象上处于等待的所有线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u.notify();</span><br></pre></td></tr></table></figure>

<h3 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h3><p>在使用的时候，必须要结合 synchronized 同步代码块来使用才能生效，否则就会报出以下异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.IllegalMonitorStateException</span><br></pre></td></tr></table></figure>

<h2 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h2><p>生产者消费者是一种多线程的模型，虽然在学习目前还没遇到过真正的使用场景。不过简单的例子还是知道的。</p>
<h3 id="生产者线程类"><a href="#生产者线程类" class="headerlink" title="生产者线程类"></a>生产者线程类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者，生产者只生产一个</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (arr) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[<span class="number">0</span>] % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        arr.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    arr[<span class="number">0</span>]++;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + arr[<span class="number">0</span>]);</span><br><span class="line">                    arr.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消费者线程类"><a href="#消费者线程类" class="headerlink" title="消费者线程类"></a>消费者线程类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (arr) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[<span class="number">0</span>] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        arr.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    arr[<span class="number">0</span>]++;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;---&gt;&quot;</span> + arr[<span class="number">0</span>]);</span><br><span class="line">                    arr.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主线程测试"><a href="#主线程测试" class="headerlink" title="主线程测试"></a>主线程测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChangeTestOut</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Producer2</span>(arr));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer2</span>(arr));</span><br><span class="line"></span><br><span class="line">        thread1.setName(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">        thread2.setName(<span class="string">&quot;消费者&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行的结果是交替进行的。</p>
<h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h2><p>volatile 作用于属性，能够保证线程之间共享数据的可见性。如何保证可见性，首先要了解 JMM（Java 内存模型），Java 内存模型如下图所示。</p>
<p><img src="/journal/java-multi-thread/3twyk3y17w.png" alt="JMM" loading="lazy"></p>
<p>其中：</p>
<ul>
<li>Java 所有变量都存储在主内存中。</li>
<li>每个线程都有自己独立的工作内存，里面存该线程的使用到的变量副本。（该副本就是主内存中该变量的一份拷贝）</li>
</ul>
<p>也就是说，每一个线程在操作数据的时候只能操作自己的工作线程，不能在主内存中读写，线程 1 无法访问线程 2  的工作内存。</p>
<p>如果要让线程 2 修改变量，让其它的线程也知道，则必须先更新主内存。主内存的数据发生变更就会自动刷新到其它的线程中。这个过程就叫做线程间可见性。</p>
<p>下面是一个例子，包含 main 线程和 thread-1 线程，就是当 main 线程中将 flag 设置为 true，thread-1 线程就会终止运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;Flag has been set to true&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;Flag has been set to true&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">VolatileDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileDemo</span>();</span><br><span class="line">    demo.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们使用了 volatile 关键字来修饰 flag 变量，这样可以保证在多线程环境下该变量的可见性，即当一个线程修改了 flag 的值后，其他线程可以立即看到这个变化。</p>
<p>在 start 方法中，我们启动了一个新的线程，在这个线程中不断地循环，直到 flag 的值被设置为 true。在主线程中，我们等待了一秒钟后将 flag 的值设置为 true。</p>
<p>由于 flag 变量被修饰为 volatile，因此在主线程中修改 flag 的值后，新线程可以立即看到这个变化，从而退出循环并输出提示信息。</p>
<p>当去掉 volatile 关键字时，main 线程虽然将 flag 设置成了 true，但是它仅仅修改了自己的工作内存，没更新主内存，因此 thread-1 会无限循环下去。</p>
<p>volatile 可以保证可见性，但是无法保证原子性。</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal 又叫线程间的局部变量，它的目的主要在于保证不同线程之间的数据不共享，在线程 A 修改 ThreadLocal 中的数据后，线程 B 中的内容不会受到线程 A 的修改而影响。</p>
<p>ThreadLocal 是用哈希表实现的，每个线程Thread维护一个 ThreadLocalMap 属性，里面就以 Map 的形式存储了多个 ThreadLocal 对象。当在线程中调用 ThreadLocal 操作方法时，都会通过当前Thread线程对象拿到线程里的 ThreadLocalMap，再通过 ThreadLocal 对象从 ThreadLocalMap 中锁定数据实体（ThreadLocalMap.Entry）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 ThreadLocal 对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 在主线程中设置 ThreadLocal 的值</span></span><br><span class="line">        threadLocal.set(<span class="string">&quot;Hello, ThreadLocal!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建新线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 在新线程中获取 ThreadLocal 的值</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- &quot;</span> + value); <span class="comment">// 输出 &quot;null&quot;，因为新线程中没有设置 ThreadLocal 的值</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动新线程</span></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ---- &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main ---- Hello, ThreadLocal!</span><br><span class="line">Thread-0 ---- null</span><br></pre></td></tr></table></figure>

<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>volatile 无法保证原子性，synchronized 和 Lock 虽可以保证原子操作（一次性操作完，不能被其它线程所影响），但是效率太低。这时可以使用 Java 内置的 atomic 包下的原子类。</p>
<p>在很多时候，我们需要的仅仅是一个简单的、高效的、线程安全的递增或者递减方案，这个方案一般需要满足以下要求：</p>
<ul>
<li>简单：操作简单，底层实现简单</li>
<li>高效：占用资源少，操作速度快</li>
<li>安全：在高并发和多线程环境下，保证数据的正确性</li>
</ul>
<p>例如以下例子，多个线程池对临界变量累加：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="comment">// 创建临界变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test3</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test3</span>();</span><br><span class="line">        <span class="comment">// 创建线程池，线程数为5</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 循环提交任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 对临界变量进行累加操作</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">200</span>; j++) &#123;</span><br><span class="line">                    t3.increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="comment">// 等待所有任务执行完毕</span></span><br><span class="line">        <span class="keyword">while</span> (!executorService.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;累加结果：&quot;</span> + t3.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次运行之后，累加的结果都不一样。这是因为 count 作为临界资源，累加时无法保证原子性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">累加结果：925</span><br><span class="line">累加结果：937</span><br><span class="line">累加结果：1000</span><br><span class="line">累加结果：984</span><br><span class="line">累加结果：937</span><br></pre></td></tr></table></figure>

<p>保持累加可以使用 AtomicInteger 类保证原子性，修改后的代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">    <span class="comment">// 创建临界变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test3</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test3</span>();</span><br><span class="line">        <span class="comment">// 创建线程池，线程数为5</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 循环提交任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 对临界变量进行累加操作</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">200</span>; j++) &#123;</span><br><span class="line">                    t3.increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        <span class="comment">// 等待所有任务执行完毕</span></span><br><span class="line">        <span class="keyword">while</span> (!executorService.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;累加结果：&quot;</span> + t3.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>incrementAndGet 类似于 i++，运行结果如下。发现每次的运行结果都是 1000。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">累加结果：1000</span><br><span class="line">累加结果：1000</span><br><span class="line">累加结果：1000</span><br><span class="line">累加结果：1000</span><br><span class="line">累加结果：1000</span><br></pre></td></tr></table></figure>

</div></section><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>BestGuo2020</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://www.bestguo.top/journal/java-multi-thread/" title="Java 的多线程">https://www.bestguo.top/journal/java-multi-thread/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> 许可协议。</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/journal/spring-cloud-totoral/" rel="prev" title="初见微服务和Spring Cloud"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">初见微服务和Spring Cloud</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/journal/view-width-and-view-height/" rel="next" title="view width 和 view height"><span class="post-nav-text">view width 和 view height</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>请诸位理性发言！</span><br><span>请勿发布违反中国大陆地区法律的言论，请勿人身攻击、谩骂、侮辱和煽动式的语言。</span><br></div><div id="waline"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@waline/client@v2/dist/waline.css"><script>window.CONFIG.waline.config.path = "/journal/java-multi-thread/"</script><div class="js-Pjax"><script src="/js/comments/waline.js" type="module" defer></script></div></div></main><footer class="sidebar-translate" id="footer"><div class="beian"><a rel="noopener" href="https://beian.miit.gov.cn/" target="_blank">赣 ICP 备 20009988 号</a></div><div class="copyright"><span>&copy; 2019 – 2023 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> BestGuo2020</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v7.0.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.11</span></div><div class="live-time"><span>本站点已正常地运行</span><span id="display_live_time"></span><span class="moe-text"><br/>♬(ノ゜∇゜)ノ♩<br></span><script>function blog_live_time() {
  setTimeout(blog_live_time, 1000);
  const start = new Date('2019-01-01T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = ` ${passDay} 天 ${passHour} 小时 ${passMinute} 分 ${passSecond} 秒`;
}
blog_live_time();
</script></div><div id="busuanzi"><span id="busuanzi_container_site_uv" title="总访客量"><span><span class="icon iconify" data-icon="ri:user-line"></span></span><span id="busuanzi_value_site_uv"></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv" title="总访问量"><span><span class="icon iconify" data-icon="ri:eye-line"></span></span><span id="busuanzi_value_site_pv"></span></span><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div class="footer-support"><span>本网站由</span><a class="footer-support-logo" href="https://www.upyun.com/?utm_source=lianmeng&amp;utm_medium=referral" target="blank" title="又拍云"><img height="30" src="https://cdn.yunyoujun.cn/img/logo/upyun-logo.png" alt="又拍云"></a><span>提供 CDN 加速服务</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:search-line"></span></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="https://fastly.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js"></script><script src="/js/search/local-search.js" defer type="module"></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><span class="icon iconify" data-icon="ri:close-line"></span></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="搜索..." value=""></div><div class="search-result-container"></div></div></body></html>